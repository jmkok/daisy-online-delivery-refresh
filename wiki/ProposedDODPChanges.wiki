#summary Proposed changes to DAISY Online Delivery Protocol v1.1
= *Proposed changes to DAISY Online Delivery Protocol v1.1* =
----
== *Introduction* ==

These are the proposed changes to DODP V1 to create V1.1, 
Please also read additional pages "Items requiring clarification" and “Proposed changes to DAISY Online Delivery Protocol V2” for additional features to be prioritized.

Protocol is implemented in different ways by different clients and servers because it is possible to interpret it in different ways as has been done by different organisations. 

As a result client developers can’t create generic clients that work across all services. Unification of implementation between organizations is required. 

This revision V1.1 is intended to assist with standardising the protocol across implementations and ensure interoperability while meeting the needs of those that have already implemented the Protocol.


== *User setup* ==

*1.* The service provider has no standard means to implement reading system setup without manual steps. This is a significant factor slowing down delivery and adoption of the online service. Currently the hardware players requires manual configuration by technical staff.

A standard-based, interoperable (manufacturer-independent) way of registering a reading system to a service would eliminate the manual steps. For example: Setting up ID, password, server address via network.*_(VA has implemented a working solution for this that we recommend…)_*

== *Content protection/managing content on devices* ==

*2.* The DODP protocol is ambiguous about whether content that has been downloaded to the reading system may or may not be transferred to an external media. Need clarification of the access that the reading system may or may not offer to borrowable content. Add the means to communicate whether or not a content item may be transferred outside of the reading system. _(a third flag that locks content to a device)_

*3.* The protocol gives no means to effectively limit usage of borrowable content to a lending period _(what about GetContentListExpired? This only applies to online devices connecting to a DODP service)._  

*4.* It is not possible to distinguish between content download and content streaming requests from the client. 

There is currently no way to know if a content item has been fully downloaded or just streamed. 
Requires a flag to indicate if download is completed.

*5.* To answer the points 2,3,4 above: 

Require a Method to inform the server when a download starts and ends and flag the download type including ability to Return an Error message when denying a download. 

*Purpose*

Method for the client to inform the server when a download event starts and when it ends and ability for the server to deny the request and return an error code with a custom message for players that support TTS. 

The method should include a flag to inform the server if the download is stream or download enabling the server to differentiate and action the two requests differently. 

Also a 3rd flag state to indicate whether content should be locked to a device.  Also, the ability to return an error code with a custom message for players with TTS to inform the client why a download request was denied. 

This method should include a flag which the player can action upon to retry or not upon conditions. 
Use case To enable prioritization of bandwidth allocation to Streaming clients to maintain a standard of service in the event of download requests overloading the pipe.

To enable the server from denying requests for download of titles where copyright does not allow download but allows streaming. 

To enable the Server to reject a download based on conditions (such as time of the day to enable off peak downloads) and inform the player if this action should be retried.  

*Technical Investigation*  

The DAISY Online service requires the ability to inform the Server that a ’download’ or ‘streaming’ operation is beginning or ending.  Add Method FinishAction(ActionSession).  This informs the service that the given action has completed.  

This is required to:
 
- Support legal requirements around some content being allowed to be streamed but NOT downloaded.
 
- Determine if a Download is allowed based on Peak/Off-peak periods.   E.g. Ability to fail a download request, but allow a streaming request. 

- Allow collection of statistics for user operations - I.e. accurately count downloads, streaming sessions etc. This method needs to be able to send a 'NO' response that also provides not only a label explaining why but also a count in minutes before retrying. 

Examples of reasons to return ‘No’ include: “This item cannot be downloaded, it can only ever be streamed” “This item cannot be downloaded now as it can only be done in Off-Peak period”.  

GetResources will need to know the download/Streaming intention so it can return the correct URL's as they may be different and therefore will be at different locations.   

This also enables access to the content to be denied and also to allow access to a single Zip/Container file rather than the individual files required for streaming. 

The individual resource script will also need to know if they are being used for download or stream enabling the resource script to, for example, fail if the time falls outside of a Off-peak period.  Recommendation:	GetContentMetadata Add new meta-data to the response such as PermittedActionType (Download, Stream, Both).   

This enables the device to know if an item can be downloaded or not at the time of building the bookshelf.   

It can then only make the option to Download available for items that can be downloaded.  (the download or streaming action would ONLY be called just prior to the action beginning and not, for instance while building the bookshelf)

*6.* At the Server level Downloads should simply be disallowed by a "serviceAttributes" parameter (is this the correct parameter? You would need both this and GetContentMeta/list, which one would be the reference) 

== *Streamlining communication with the server* ==

*7.* As contentLists only contain titles, with apps typically you want to show more, such as cover images, author, format, return date etc. 

As a consequence, our app needs to call getContentMetadata for each item. 

Add a few metadata fields to contentlists so that they can be loaded on the screen more efficiently. 
For example: cover image, author, publisher, DTBtype, containsBookmarks, containsLastmark.

*8.* Reading System - Minimize the number of requests and communication steps. There are many steps required before connecting (a high latency connection suffers). 
This could be resolved by combining requests into one call, perhaps a ‘richer’ GetContentlist? 
Could also Reduce the steps (requests) required to obtain contentMetadata. 

*9.* Modify operation getContentList - The operation getContentList should be able to return a list that includes contentMetadata. Since getContentList can only return a list of IDs and labels, getContentMetadata must be called for every returned ID. We suggest that that getContentList returns a list where every element also includes the contentMetadata. If desired, the readingSystemAttributes and serviceAttributes structures could also provide a means for handshaking when it comes to deciding on which meta data fields to actually include in the contentMetadata.

*10.* Modify operation logOn

The logOn operation should include the functionality in the getServiceAttributes and setReadingSystemAttributes operations. 

For example in the case of DAISY Content consisting only of text based Daisy 3, the DODP itself becomes a noticeable share of the data. This, along with delays in the mobile network, makes the DODP requests ”expensive”. 

As a solution, we propose that certain requests, those that need to be performed sequentially anyway, are joined into a common request, a combination of logOn, getServiceAttributes and setReadingSystemAttributes.

The readingSystemAttributes can be included in the request and the serviceAttributes can be returned in the response of the logOn operation.

== *Dynamic Menu items* ==

*11.* Create an examples of how to use the dynamic menus. Perhaps provide a "best practice"" implementation. E.g. for searching content. There is no standard way of searching books across various server implementations. (Clarify this point – is searching too loose?  Base this on existing implementations)

*12.* Dynamic menus should be able to reference to a content item directly (instead via a content list) (Investigate if it can be done, and why wasn’t it done if it can) 

*13.* More detailed use of Questions Method (Provide a standard minimum list of searchable items… Part of a ‘base line’ implementation to ensure baseline interoperability)

== *Limitations/Communication/delivery suggestions* ==

*14.* Delivery systems should be required to support range requests. Removal of the text: "As it is not possible to require support for range headers on Service Delegates, Reading Systems must be able to handle servers that do not support range headers." (Agreed – spec is contradictory.  Which is right? Is there any downside for not supporting range requests?)

== *Bookmarks* ==

*15.* Sending all the bookmark data every time the client causes unnecessary load on the server. This especially happens when a client wishes to update individual bookmarks or lastmark and the book has a great number of bookmarks and ‘hilites’.

There are 3 options to deal with this:

 *Possible Solution 1: There should be a recommendation that the client calls setBookmarks only at the end of a reading session. To keep server load and bandwidth at a minimum the client should be “intelligent”, making as few requests as possible while keeping the bookmark data on the server reasonably up to date. (Is this really a large load on the server? Is this an issue of the device sending too many updates to the server?)

 *Possible Solution 2: setBookmarks new operations - There should be separate operations for setting and removing lastmark, bookmark and ‘hilite’.   

Also getBookmarks new operation - There should be a separate operation for getting lastmark so that the client can fetch bookmarks and markings in a separate request. 
In a typical scenario, the user opens a book and expects to arrive where the reading/listening was interrupted/paused the last time and the user expects this to happen as quickly as possible. 
If any other bookmark data is needed, this can be loaded in the background or immediately afterwards. (note two recommendations in this solution)

 *Possible Solution 3: Add method ”addBookmark”. The backend will generate a bookmarkID and return this ID back to the player. From then on this id can be used to alter a bookmark.  Also Add method “removebookmark”.

== *New Features and Enhancements* ==

*16.* Allow actions without user credentials (this allows demo purposes for users without an account yet), for example searching or browsing a catalogue of books via the dynamic menu before actually deciding to use the service and become a member/customer. (Does the protocol stipulate that you have to be logged in to do a search?  Can this be done on the server side – by allowing a guest logon, and setting the rules so that if a logon is not received, it allows access to the catalogue)

*17.* Allow samples to be issued. This way samples can be handled the same way as “normal” content. (Can this can be done now? What functionality would there be?)

*18.* Enhance Custom Messages, Outage Management and Emergency notifications and update guidelines as necessary.

*Purpose*

To enable the delivery of a short message to be played by the device to communicate to the client that a shutdown is imminent and additional information by introducing a protocol recognized standard HTTP error code. 

The ability to return a message when denying access on log on returning a standard code for scheduled maintenance and the ability to return a custom message for players that have inbuilt TTS. 

Use case Enable to warn users of a soft shut down, deny further authentications with an information packet while enabling current users to finish their actions before the shutdown occurs.

*Technical Investigation*

Stop New Connections No change to Protocol required. Just need to extend the service so that the Login method checks server status and return the relevant exception code.

This will also need to write the extended message when failing the login.

Stop All Connections Now No change to Protocol required. Just need to extend the service so that it checks server status and return the relevant exception code.

This will also need to write the extended message when failing the login. Custom messages A variety of exceptions may occur where a more meaningful message can be returned and rendered to the user device.   The label available within the Fault can be used to return a detailed message containing such information.

For example:

1.“service denied error - Please agree to Terms of Service and re-try”

2.“download request rejected - Item cannot be Downloaded at this time, please retry in off-peak period” 

3.Outage message The label available within the Fault can be used to return a detailed message containing information regarding the outage.

As only devices with built in synthetic voice could render such a message, devices without synthetic voice will need a standard message based on the fault code. Announcement Polling The device should poll every X mins to look for new Announcement.

If a New Announcement exists and it is of the relevant priority (1) then the device can interrupt the current process and inform the user of the alert. (This would be used for Emergency messages, Imminent Unplanned Service outages etc.)

It would be useful if Service Attributes could define the preferred polling time so this time could be controlled at the service end.

*Recommendation*

Standardising the meaning of Priority 1 (and 2 & 3) Announcement’s that specifies that these messages should interrupt the current user activity with the Announcement. 

Add Announcement polling time parameter to the GetServiceAttributes response. The DAISY Online standard describes the use of the exception codes.   “Each of these fault types has a reason child element, a string which can be used to send debugging information to the Reading System.   The Information should not be rendered to the User in most cases”.    (Confirm that the proposed usage does not conflict with the intention of the above statement, ‘The Information should not be rendered to the User in most cases’ and update usage guideline as necessary). 

*21.* Terms of Service Status  Purpose  To enable the protocol to manage terms of service with provisions for presenting a client with terms and conditions that must be agreed on and return this information to the server. The server would present ToS only if the client has not agreed to them in another device or webpage related to the service. Use case When authenticating with the server if a user has not agreed to terms of service DOP will send these and return if the client has agreed to or not to the Server before allowing the device to proceed with the service.  Recommendation  Add the following additional methods to the protocol standard; 
1. GetTermsOfService -  Returns Terms of Service Text and question. 
2. MarkTermsOfServiceAsRead -  Updates the ‘Agreed to Terms of Service’ flag to True. 
Change GetContentList method to fail when Terms of Service have not been agreed returning a new fault code. Add a new attribute to the GetServiceAttribute response called TERMS_OF_SERVICE.   This would determine if the Terms of Service methods are supported.   I.e. if the user has not agreed then they will not be able to access content.   The device can use the API to manage the agreement or recommend the user arranges for this outside of the device.  

*22.* Shifting ReturnBy Date  Purpose  Currently a ReturnBy date is made available for each individual resource file returned by the method GetResources.   I believe the ReturnBy date is associated with the ContentItem and not the individual resource files.   I.e. I cannot currently see a case where some resource files would have a different ReturnBy date to other resource files within the same ContentItem. This causes some devices to call GetResources at the time of building the Bookshelf which could be argued is unnecessary.   E.g. IF a User ha 10 items on their bookshelf but was only interested in streaming 1 of them in a given session, then GetResources would have been called 9 times unnecessarily. If this is True, then it would be better If the ReturnBy Date in GetResources is shifted to GetContentMetadata then GetResources does not need to be called to build the booklist and is only required when an action (Download or Stream) is about to begin.  Recommendation  Shift the ReturnBy date from GetResources to GetContentMetadata."

*23.* lastItem recommendation/clarification - In DODP there should be included a recommendation that the client implements a max value for the request parameter lastItem which takes into account the capacity of the client regarding the number of elements that can be presented in a list at a time. In the case of MTM, there is the risk that a search will result in tens of thousands of titles. Now, if the client immediately fetches the entire search result, it will cause unnecessary load on the DOD server. Bandwidth is almost certainly wasted as it is unlikely that the borrower is interested in more than the first ten or so results. There is also the added inconvenience that the application may be perceived as slow/non-responsive. Also, n the description of the response object, it is stated that an empty list should be returned when firstItem and lastItem are invalid. However, there are no examples with concrete values that illustrate when firstItem and lastItem may be considered invalid. (usage guideline)

*24.* New and issued content - A clarification is needed regarding how new and issued content lists are intended to be used in the bookshelf. Today, there are different interpretations depending on use cases and number of titles. For example, there are clients that only look at new, download these to the player and then consider issued to be the same thing as completed downloads. In these cases, there is no point in asking for issued, but this only works if the same, single, client is used all the time. We assume, however, that the users will at least once switch to a different client. A related question is the interpretation of new and issued. Is a new book one that is new in the total collection or in the bookshelf? For a library with a long range of titles and considerable new production, ”new book in the collection” becomes extremely ambiguous.

*25.* To support peak/off-peak usage; add 2 New fault codes for GetResources to be used by devices without synthetic voice to determine if the failure is caused by the server not allowing the action.   The fault codes need to communicate if the download rejection should be retried later or should not.   i.e. A Book which is ‘Stream Only’ should not be retried, however, a book download attempt in Peak period should retry later. eg. AccessRejected, AccessRejectedRetry.  The individual URI’s returned from GetResources cannot return a detailed message as it is not a SOAP call and therefore does not return the standard SOAP faults.  Therefore, specific fault codes are suggested as above.